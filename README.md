# Автоматизация релизов и обновлений зависимостей

## Цель исследования

Проверить применимость Renovate для автоматического обновления корпоративных
npm-пакетов в проектах-потребителях, снизить ручную нагрузку на команду и
повысить предсказуемость обновлений зависимостей.

В рамках пилота был протестирован сценарий обновления внутреннего пакета
`renovate-pilot-package` в consumer-проекте с использованием GitHub и npm
Registry.

- управления версиями npm-пакетов;
- публикации релизов;
- обновления зависимостей в потребляющих проектах;
- минимизации ручных действий и человеческого фактора.

---

## Как это работает? 

| Этап | Что происходит | Результат |
|------|----------------|-----------|
| **1. Библиотека** | Разработчик делает коммит с префиксом `feat:`, `fix:` | Готовый код для релиза |
| **2. Semantic Release** | Анализирует историю коммитов, определяет тип версии (major/minor/patch) | Номер версии (1.2.3), CHANGELOG.md |
| **3. npm Registry** | Принимает новый пакет от Semantic Release | Пакет доступен для установки |
| **4. Renovate** | Видит новую версию в registry, проверяет правила конфигурации | Merge Request в проектах-потребителях |
| **5. Потребители** | Получают MR, CI запускает тесты | Автоматический мерж после успешного CI |

**Полная цепочка:** `Коммит → Анализ → Версионирование → Публикация → Обнаружение → Обновление`

## Почему это важно для нас? 

### Проблема (было)
- Обновление зависимостей — рутина, которую все откладывают
- Версии в `package.json` расходятся между проектами
- Кто отвечает за обновления? Никто, пока не сломается
- Человеческий фактор: забыли обновить, ошиблись в версии

### Решение (стало)
- **Автоматически**: Обновления приходят как MR
- **Контролируемо**: Только нужные пакеты, по нашим правилам
- **Безопасно**: Automerge только после успешного CI
- **Предсказуемо**: Conventional Commits → Semantic Release → Renovate


Для снижения рисков используется многоступенчатая схема публикаций.

Renovate настраиваем **точечно**, чтобы не заспамить команду.

### Что обновляем:
| Тип пакета | Стратегия | Automerge | Примечание |
|------------|-----------|-----------|------------|
| Внутренние библиотеки | `replace` | ✅ patch/minor<br/>❌ major | Основной фокус |
| Внешние зависимости | Отключены | — | Обновляем вручную при необходимости |


## Пример конфигурации:

```json
{
	"$schema": "https://docs.renovatebot.com/renovate-schema.json",
	"extends": ["config:recommended"],
	"reviewers": ["@renovatebot/maintainers"],
	"automergeType": "pr",
	"dependencyDashboard": true,
	"labels": ["renovate"],
	"schedule": ["before 4am on Monday"],
	"packageRules": [
		{
			"description": "Use replace strategy for internal package",
			"matchManagers": ["npm"],
			"matchPackageNames": ["renovate-pilot-package"],
			"rangeStrategy": "replace"
		},
		{
			"description": "Automerge patch/minor updates for internal package",
			"matchManagers": ["npm"],
			"matchPackageNames": ["renovate-pilot-package"],
			"matchUpdateTypes": ["patch", "minor"],
			"automerge": true,
			"automergeType": "pr"
		},
		{
			"description": "Disable automerge for major updates",
			"matchManagers": ["npm"],
			"matchPackageNames": ["renovate-pilot-package"],
			"matchUpdateTypes": ["major"],
			"automerge": false
		},
		{
			"description": "Disable all other npm dependencies",
			"matchManagers": ["npm"],
			"enabled": false,
			"matchPackageNames": ["!renovate-pilot-package"]
		}
	]
}
```

## Что нужно от разработчика?

Для автора библиотеки:
 1. Пишите коммиты в формате Conventional Commits:
 2. Работайте через feature-ветки и MR
 3. Semantic Release сделает всё остальное

Для потребителя библиотеки:
1. Просто работайте в своём проекте
2. Когда выйдет новая версия библиотеки — получите MR от Renovate
3. Если это patch/minor и CI зелёный — MR замерджится сам
4. Если major — проведите ревью как обычно

---

## Renovate: автоматическое обновление зависимостей

Renovate используется для отслеживания и обновления зависимостей в потребляющих
проектах.

Он:

- отслеживает версии пакетов;
- сравнивает их с реестром;
- создаёт Merge Request’ы;
- при необходимости автоматически мержит обновления.

---

### Как работает Renovate

Renovate — это инструмент для автоматического управления зависимостями, который
работает в несколько чётких этапов. Он не “обновляет всё подряд”, а действует
строго по конфигурации и текущему состоянию репозитория.

#### Этап 1. Сканирование репозитория

При запуске Renovate:

- клонирует репозиторий;
- читает конфигурацию (`renovate.json`);
- определяет менеджеры зависимостей (npm, github-actions и т.д.);
- извлекает список зависимостей и их текущие версии.

На этом этапе Renovate **ничего не меняет** — только собирает данные.

---

#### Этап 2. Проверка источников версий

Для каждой зависимости Renovate:

- обращается к соответствующему реестру (npm, GitLab Package Registry и т.д.);
- определяет latest-версию и доступные dist-tags;
- сравнивает их с текущей версией в проекте;
- классифицирует обновление как `patch / minor / major`.

Если версия не изменилась или обновление запрещено конфигом — зависимость
пропускается.

---

#### Этап 3. Применение packageRules

Далее применяется логика `packageRules`:

- фильтрация по имени пакета;
- фильтрация по менеджеру (`npm`, `github-actions`);
- фильтрация по типу обновления;
- решение:
  - создавать MR или нет;
  - включать automerge или нет;
  - игнорировать зависимость полностью.

Именно **packageRules определяют, какие пакеты Renovate “видит”, а какие —
игнорирует**.

---

#### Этап 4. Создание ветки и Merge Request

Если обновление разрешено:

- создаётся отдельная ветка;
- версия зависимости обновляется;
- коммит оформляется в формате Conventional Commits;
- создаётся Merge Request с описанием изменений.

На этом этапе Renovate **не мержит изменения**, даже если automerge включён.

---

#### Этап 5. Ожидание CI и проверок

Renovate отслеживает:

- статус pipeline;
- protected branches;
- правила approvals;
- актуальность ветки относительно base branch.

Если ветка устарела или проверки не прошли — Renovate ждёт или делает rebase.

---

#### Этап 6. Automerge (если разрешён)

Automerge выполняется **только если одновременно выполнены условия**:

- обновление разрешено правилами;
- CI завершился успешно;
- ветка актуальна;
- нет блокирующих правил GitLab (approvals, code owners и т.д.).

Важно:

> Renovate **не мержит PR в том же запуске**, в котором он был создан.  
> Automerge происходит на **следующем запуске Renovate**.

Это часто выглядит как “почему не замерджилось сразу”, хотя это ожидаемое
поведение.

---

#### Этап 7. Dependency Dashboard

Если включён `dependencyDashboard`:

- Renovate создаёт issue;
- в нём отображаются:
  - найденные зависимости;
  - доступные обновления;
  - rate-limited PR’ы;
  - обновления, ожидающие ручного действия.

Dashboard — это **панель управления Renovate**, а не ошибка или предупреждение.

---

#### Важные особенности поведения

- Renovate не обновляет зависимость, если:
  - версия уже удовлетворяет диапазону (`^1.0.0` и `1.0.1`);
  - обновление было ранее отклонено;
  - оно попало под `enabled: false`;
  - оно rate-limited.

- Renovate всегда ориентируется на **base branch** (обычно `main`).
- Любые изменения в конфиге применяются **только со следующего запуска**.

---

#### Ключевой вывод

Renovate — это не “автоапдейтер”, а **policy engine**:

- он исполняет правила;
- не нарушает ограничений репозитория;
- не принимает решений без явного разрешения в конфиге.

Если Renovate не обновляет пакет —  
значит **он следует правилам**, а не “сломался”.

## Ограничение области ответственности Renovate

Для снижения шума Renovate настраивается **только на нужные пакеты**.

Принцип:

- автоматизируем обновления внутренних библиотек;
- остальные зависимости либо отключены, либо обновляются вручную.

### Пример логики

- `PATCH` / `MINOR` для внутренних пакетов → automerge
- `MAJOR` → только вручную
- остальные npm-зависимости → отключены

---

## 6. GitHub как пилот, GitLab как production

GitHub использовался **исключительно как пилотная площадка**:

- быстрее настраивать;
- проще дебажить;
- удобнее демонстрировать механику.

---

## 7. Использование Renovate в GitLab

Renovate официально поддерживает GitLab и полностью интегрируется в его
экосистему.

### Что Renovate делает в GitLab

- создаёт Merge Request’ы;
- учитывает protected branches;
- работает с approvals;
- проверяет статус pipeline;
- поддерживает GitLab Package Registry.

---

## 8. Способы запуска Renovate в GitLab

### Вариант 1. GitLab CI

Renovate запускается как job в `.gitlab-ci.yml`:

- по расписанию;
- либо вручную.

Используется официальный Docker-образ `renovate/renovate`.

**Плюсы:**

- self-hosted;
- контроль безопасности;
- простая интеграция.

---

### Вариант 2. Отдельный Docker / Kubernetes CronJob

Renovate разворачивается как отдельный сервис:

- cron;
- либо Kubernetes CronJob.

Подходит для:

- централизованного обслуживания множества репозиториев;
- DevOps-подхода “Renovate as a Service”.

---

## 9. Automerge в GitLab

Renovate поддерживает два сценария:

### PR-based automerge

- создаётся MR;
- ожидается успешный pipeline;
- merge выполняется при следующем запуске Renovate.

### Branch-based automerge

- изменения коммитятся напрямую;
- MR создаётся только при проблемах.

**Рекомендуемая стратегия:**

- PATCH / MINOR → PR-based automerge
- MAJOR → ручной merge

---

## 10. Работа с GitLab Package Registry

Renovate корректно работает с:

- приватными npm-пакетами;
- scoped пакетами;
- GitLab Package Registry.

Требуется токен с правами `read_package_registry`.

---

## 11. Преимущества для команды

- **Прозрачность** — версия определяется историей коммитов.
- **Скорость** — никаких ручных правок `package.json`.
- **Надёжность** — changelog всегда соответствует фактическим изменениям.
- **Гибкость** — поддержка alpha / beta без риска для production.

---

## 12. Что требуется от разработчика

- соблюдать Conventional Commits;
- работать через feature-ветки;
- мержить изменения через Merge Request.

Всё остальное:

- версия,
- релиз,
- changelog,
- публикация — выполняет CI и автоматизация.

---

### 13. Конфигурация Renovate

Основные принципы конфигурации:

- Renovate следит **только за корпоративным пакетом**.
- Все остальные npm-зависимости отключены.
- Для внутреннего пакета используется стратегия `replace`, чтобы версия в
  `package.json` всегда указывала на конкретный релиз.



## доп настройки для удобства пользования

### Как следить за несколькими internal-пакетами:

```json
{
	"groupName": "Internal Core Packages",
	"matchPackagePatterns": ["^@ipro3/"]
}
```

## Итог

В результате внедрения:

- релизы стали предсказуемыми;
- обновления зависимостей — контролируемыми;
- ручная работа по версиям устранена;
- процесс масштабируем и подходит для GitLab-среды.

Разработчику достаточно писать корректные коммиты — **остальное делает система**
